// Generated by CoffeeScript 1.7.1
(function() {
  var Backbone, Response, SubscriptionMan, channelInterface, helpers, queryClient, queryServer, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Backbone = require('backbone4000');

  _ = require('underscore');

  helpers = require('helpers');

  SubscriptionMan = exports.SubscriptionMan = require('subscriptionman2').fancy;

  channelInterface = exports.channelInterface = Backbone.Model.extend4000({
    initialize: function() {
      return this.channels = {};
    },
    channel: function(channelname) {
      var channel;
      if (channel = this.channels[channelname]) {
        return channel;
      }
      channel = this.channels[channelname] = new this.ChannelClass({
        parent: this,
        name: channelname
      });
      channel.once('del', (function(_this) {
        return function() {
          return delete _this.channels[channelname];
        };
      })(this));
      return channel;
    },
    channelsubscribe: function(channelname, pattern, callback) {
      var channel;
      channel = this.channel(channelname);
      if (!callback && pattern.constructor === Function) {
        callback = pattern;
        pattern = true;
      }
      return channel.subscribe(pattern, callback);
    },
    broadcast: function(channel, message) {
      return true;
    },
    join: function(channel, listener) {
      return true;
    },
    part: function(channel, listener) {
      return true;
    },
    del: function() {
      return true;
    }
  });

  queryClient = exports.queryClient = Backbone.Model.extend4000({
    initialize: function() {
      return this.queries = [];
    },
    queryReplyReceive: function(msg) {
      var callback;
      if (!(callback = this.queries[msg.id])) {
        return;
      }
      if (!msg.end) {
        return callback(msg.payload, false);
      } else {
        callback(msg.payload, true);
        return delete this.queries[msg.id];
      }
    },
    query: function(msg, callback) {
      var id;
      id = helpers.uuid(10);
      this.queries[id] = callback;
      this.socket.emit('query', {
        id: id,
        payload: msg
      });
      return true;
    }
  });

  Response = (function(_super) {
    __extends(Response, _super);

    function Response(id, client, parent) {
      this.id = id;
      this.client = client;
      this.parent = parent;
    }

    Response.prototype._makereply = function(payload) {
      var msg;
      if (this.ended) {
        throw 'this response already ended';
      }
      msg = {};
      msg.id = this.id;
      if (payload) {
        msg.payload = payload;
      }
      return msg;
    };

    Response.prototype.write = function(payload) {
      console.log("<", this.id, payload);
      return this.client.emit('reply', this._makereply(payload));
    };

    Response.prototype.end = function(payload) {
      console.log("<<", this.id, payload);
      this.client.emit('reply', _.extend(this._makereply(payload), {
        end: true
      }));
      this.emit('end');
      delete this.parent.response[this.id];
      return this.ended = true;
    };

    Response.prototype.cancel = function() {
      this.emit('cancel');
      return this.end();
    };

    return Response;

  })(require('events').EventEmitter);

  queryServer = exports.queryServer = SubscriptionMan.extend4000({
    initialize: function() {
      return this.responses = {};
    },
    queryReceive: function(msg, client, realm) {
      var response;
      console.log('>', msg.id, msg.payload);
      if (!msg.payload || !msg.id) {
        return console.warn('invalid query message received:', msg);
      }
      this.responses[msg.id] = response = new Response(msg.id, client, this);
      return this.event(msg.payload, response, realm);
    },
    queryCancelReceive: function(msg, client, realm) {
      var _ref;
      console.log('X', msg.id);
      return (_ref = this.responses[msg.id]) != null ? _ref.cancel() : void 0;
    },
    subscribe: function(pattern, callback) {
      if (!callback && pattern.constructor === Function) {
        callback = pattern && (pattern = true);
      }
      return this.subscribe(pattern, callback);
    }
  });

}).call(this);
