// Generated by CoffeeScript 1.7.1
(function() {
  var Backbone, Channel, ChannelServer, SubscriptionMan, helpers, io, lweb, shared, _;

  io = require('socket.io');

  Backbone = require('backbone4000');

  helpers = require('helpers');

  _ = require('underscore');

  SubscriptionMan = require('subscriptionman2');

  _.extend(exports, shared = require('./shared'));

  Channel = SubscriptionMan.fancy.extend4000({
    initialize: function() {
      this.name = this.get('name' || (function() {
        throw 'channel needs a name';
      })());
      return this.clients = {};
    },
    join: function(reply, realm) {
      console.log('join to', this.name, client.id);
      this.clients.push = reply;
      return client.on('disconnect', (function(_this) {
        return function() {
          return _this.part(client);
        };
      })(this));
    },
    part: function(client) {
      console.log('part from', this.name, client.id);
      delete this.clients[client.id];
      if (_.isEmpty(this.clients)) {
        return this.del();
      }
    },
    broadcast: function(msg, exclude) {
      this.event(msg);
      return _.map(this.clients, (function(_this) {
        return function(subscriber) {
          if (subscriber !== exclude) {
            return subscriber.emit(_this.name, msg);
          }
        };
      })(this));
    },
    del: function() {
      this.clients = {};
      return this.trigger('del');
    }
  });

  ChannelServer = shared.channelInterface.extend4000({
    ChannelClass: Channel,
    initialize: function() {
      return this.channels = {};
    },
    broadcast: function(channelname, msg) {
      var channel;
      console.log('broadcast', channelname, msg);
      if (!(channel = this.channels[channelname])) {
        return;
      }
      return channel.broadcast(msg);
    },
    join: function(channelname, client) {
      return this.channel(channelname).join(client);
    },
    part: function(channelname, socket) {
      var channel;
      if (!(channel = this.channels[channelname])) {
        return;
      }
      return channel.part(socket);
    }
  });

  lweb = exports.lweb = shared.SubscriptionMan.extend4000(shared.queryClient, shared.queryServer, ChannelServer, {
    initialize: function() {
      var http;
      http = this.get('http');
      if (!http) {
        throw "I need http instance in order to listen";
      }
      this.server = io.listen(http, {
        log: false
      });
      this.server.on('connection', (function(_this) {
        return function(client) {
          var host, id, realm;
          id = client.id;
          host = client.handshake.address.address;
          realm = {};
          realm.client = client;
          client.on('query', function(msg) {
            return _this.queryReceive(msg, client, realm);
          });
          return client.on('reply', function(msg) {
            return _this.queryReplyReceive(msg, client, realm);
          });
        };
      })(this));
      return this.subscribe({
        join: String
      }, (function(_this) {
        return function(msg, reply, realm) {
          reply.write({
            joined: msg.join
          });
          return _this.channel(msg.join).join(reply, realm);
        };
      })(this));

      /*
      testyloopy = =>
          @broadcast 'testchannel', ping: helpers.uuid()
          helpers.sleep 10000, testyloopy
      testyloopy()
       */
    }
  });

}).call(this);
